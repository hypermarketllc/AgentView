<!doctype html>
<html lang="en" class="h-full bg-gray-50">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/crm/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>MyAgentView CRM</title>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
      @supports (font-variation-settings: normal) {
        html { font-family: 'Inter var', sans-serif; }
      }
    </style>
  </head>
  <body class="h-full bg-gray-50">
    <div id="root" class="h-full"></div>
    <script type="module" src="/src/main.tsx"></script>
  <script>
// Permission Checks Fix
(function() {
  console.log('[Permission Checks Fix] Initializing...');
  
  // Define default permissions for different user types
  const DEFAULT_BASIC_PERMISSIONS = {
    dashboard: { view: true },
    "post-deal": { view: true, edit: true, create: true },
    book: { view: true, edit: true },
    settings: { view: true, edit: true }
  };
  
  const DEFAULT_ADMIN_PERMISSIONS = {
    dashboard: { view: true, edit: true, create: true, delete: true },
    "post-deal": { view: true, edit: true, create: true, delete: true },
    book: { view: true, edit: true, create: true, delete: true },
    agents: { view: true, edit: true, create: true, delete: true },
    configuration: { view: true, edit: true, create: true, delete: true },
    monitoring: { view: true, edit: true, create: true, delete: true },
    settings: { view: true, edit: true, create: true, delete: true },
    analytics: { view: true, edit: true, create: true, delete: true },
    users: { view: true, edit: true, create: true, delete: true }
  };
  
  // Helper function to normalize user object
  function normalizeUser(user) {
    if (!user) return null;
    
    // Handle nested user object
    if (user.user && typeof user.user === 'object') {
      return user.user;
    }
    
    return user;
  }
  
  // Helper function to check if user is admin
  function isAdmin(user) {
    if (!user) return false;
    
    const normalizedUser = normalizeUser(user);
    
    // Check various ways to identify admin
    return (
      (normalizedUser.role === 'admin') ||
      (normalizedUser.email === 'admin@americancoveragecenter.com') ||
      (normalizedUser.position && normalizedUser.position.is_admin) ||
      (normalizedUser.position_id === 6)
    );
  }
  
  // Helper function to get position from user
  function getPosition(user) {
    if (!user) return null;
    
    const normalizedUser = normalizeUser(user);
    
    // Return position if it exists
    if (normalizedUser.position) {
      return normalizedUser.position;
    }
    
    // Create default position based on role
    return {
      id: normalizedUser.position_id || (normalizedUser.role === 'admin' ? 6 : 1),
      name: normalizedUser.role === 'admin' ? 'Admin' : 'Agent',
      level: normalizedUser.role === 'admin' ? 6 : 1,
      is_admin: normalizedUser.role === 'admin',
      permissions: normalizedUser.role === 'admin' ? DEFAULT_ADMIN_PERMISSIONS : DEFAULT_BASIC_PERMISSIONS
    };
  }
  
  // Helper function to get permissions for a user
  function getPermissions(user) {
    if (!user) return {};
    
    const normalizedUser = normalizeUser(user);
    
    // If admin, return admin permissions
    if (isAdmin(normalizedUser)) {
      return DEFAULT_ADMIN_PERMISSIONS;
    }
    
    // Get position
    const position = getPosition(normalizedUser);
    
    // Return position permissions or default basic permissions
    return (position && position.permissions) ? position.permissions : DEFAULT_BASIC_PERMISSIONS;
  }
  
  // Patch the permission checking function
  function patchPermissionChecking() {
    // Find all potential permission checking functions
    const potentialFunctions = [
      'hasPermission',
      'checkPermission',
      'canAccess',
      'hasAccess',
      'checkAccess'
    ];
    
    let patchedCount = 0;
    
    // Try to find and patch each function
    for (const funcName of potentialFunctions) {
      if (typeof window[funcName] === 'function') {
        const originalFunc = window[funcName];
        
        window[funcName] = function(user, section, action) {
          console.log(`[Permission Checks Fix] Checking access for ${section}/${action}`);
          
          // If no user, deny access
          if (!user) {
            console.log(`[Permission Checks Fix] No user, denying access to ${section}/${action}`);
            return false;
          }
          
          // If admin, grant access
          if (isAdmin(user)) {
            console.log(`[Permission Checks Fix] User is admin, granting access to ${section}/${action}`);
            return true;
          }
          
          // Get permissions
          const permissions = getPermissions(user);
          
          // Check if section exists in permissions
          if (!permissions[section]) {
            console.log(`[Permission Checks Fix] No permission found for section: ${section}, checking defaults`);
            
            // Check default permissions
            const defaultPermissions = DEFAULT_BASIC_PERMISSIONS;
            if (defaultPermissions[section] && defaultPermissions[section][action]) {
              console.log(`[Permission Checks Fix] Default permission grants access to ${section}/${action}`);
              return true;
            }
            
            console.log(`[Permission Checks Fix] No permission found for ${section}/${action}, denying access`);
            return false;
          }
          
          // Check if action exists in section permissions
          if (!permissions[section][action]) {
            console.log(`[Permission Checks Fix] No permission found for action ${action} in section ${section}, denying access`);
            return false;
          }
          
          console.log(`[Permission Checks Fix] Access for ${section}/${action}: ${permissions[section][action]}`);
          return permissions[section][action];
        };
        
        patchedCount++;
        console.log(`[Permission Checks Fix] Patched ${funcName} function`);
      }
    }
    
    // If no functions were patched, create a global permission checking function
    if (patchedCount === 0) {
      window.hasPermission = function(user, section, action) {
        console.log(`[Permission Checks Fix] Checking access for ${section}/${action}`);
        
        // If no user, deny access
        if (!user) {
          console.log(`[Permission Checks Fix] No user, denying access to ${section}/${action}`);
          return false;
        }
        
        // If admin, grant access
        if (isAdmin(user)) {
          console.log(`[Permission Checks Fix] User is admin, granting access to ${section}/${action}`);
          return true;
        }
        
        // Get permissions
        const permissions = getPermissions(user);
        
        // Check if section exists in permissions
        if (!permissions[section]) {
          console.log(`[Permission Checks Fix] No permission found for section: ${section}, checking defaults`);
          
          // Check default permissions
          const defaultPermissions = DEFAULT_BASIC_PERMISSIONS;
          if (defaultPermissions[section] && defaultPermissions[section][action]) {
            console.log(`[Permission Checks Fix] Default permission grants access to ${section}/${action}`);
            return true;
          }
          
          console.log(`[Permission Checks Fix] No permission found for ${section}/${action}, denying access`);
          return false;
        }
        
        // Check if action exists in section permissions
        if (!permissions[section][action]) {
          console.log(`[Permission Checks Fix] No permission found for action ${action} in section ${section}, denying access`);
          return false;
        }
        
        console.log(`[Permission Checks Fix] Access for ${section}/${action}: ${permissions[section][action]}`);
        return permissions[section][action];
      };
      
      console.log('[Permission Checks Fix] Created global hasPermission function');
    }
  }
  
  // Patch the permission provider component
  function patchPermissionProvider() {
    // Wait for React components to be loaded
    const checkInterval = setInterval(() => {
      // Look for permission provider or context
      const permissionComponents = [
        'PermissionProvider',
        'PermissionContext',
        'AuthContext',
        'AuthProvider'
      ];
      
      let found = false;
      
      for (const componentName of permissionComponents) {
        if (window[componentName]) {
          console.log(`[Permission Checks Fix] Found ${componentName}, patching...`);
          
          // Store original component
          const originalComponent = window[componentName];
          
          // Override with patched version
          window[componentName] = function(...args) {
            const result = originalComponent.apply(this, args);
            
            // If result has a value property (React context)
            if (result && result.value) {
              // Add our permission checking function
              if (!result.value.hasPermission) {
                result.value.hasPermission = function(section, action) {
                  const user = result.value.user || result.value.currentUser;
                  return window.hasPermission(user, section, action);
                };
              }
            }
            
            return result;
          };
          
          found = true;
          console.log(`[Permission Checks Fix] Patched ${componentName}`);
        }
      }
      
      if (found) {
        clearInterval(checkInterval);
        console.log('[Permission Checks Fix] Successfully patched permission components');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Patch React components that check permissions
  function patchReactComponents() {
    // Wait for React to be loaded
    const checkInterval = setInterval(() => {
      if (window.React) {
        console.log('[Permission Checks Fix] React found, patching components...');
        
        // Original createElement function
        const originalCreateElement = window.React.createElement;
        
        // Override createElement to patch components
        window.React.createElement = function(type, props, ...children) {
          // If component has permission props
          if (props && (props.requiredPermission || props.requiredSection || props.requiredAction)) {
            const section = props.requiredSection || props.requiredPermission;
            const action = props.requiredAction || 'view';
            
            // Get current user from props or global state
            const user = props.user || (window.store && window.store.getState && window.store.getState().auth && window.store.getState().auth.user);
            
            // Check permission
            const hasPermission = window.hasPermission(user, section, action);
            
            // If no permission, return null or fallback
            if (!hasPermission && props.fallback) {
              return originalCreateElement.apply(this, [props.fallback, null, ...children]);
            } else if (!hasPermission) {
              return null;
            }
          }
          
          // Call original function
          return originalCreateElement.apply(this, [type, props, ...children]);
        };
        
        clearInterval(checkInterval);
        console.log('[Permission Checks Fix] Successfully patched React components');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Override permission checking in Redux store
  function patchReduxStore() {
    // Wait for Redux store to be loaded
    const checkInterval = setInterval(() => {
      if (window.store && window.store.getState) {
        console.log('[Permission Checks Fix] Redux store found, patching...');
        
        // Original getState function
        const originalGetState = window.store.getState;
        
        // Override getState to patch auth state
        window.store.getState = function() {
          const state = originalGetState.apply(this);
          
          // If state has auth
          if (state && state.auth) {
            // Ensure user exists
            if (!state.auth.user) {
              state.auth.user = null;
            }
            
            // Add permission checking function
            if (!state.auth.hasPermission) {
              state.auth.hasPermission = function(section, action) {
                return window.hasPermission(state.auth.user, section, action);
              };
            }
            
            // Add isAdmin function
            if (!state.auth.isAdmin) {
              state.auth.isAdmin = function() {
                return isAdmin(state.auth.user);
              };
            }
          }
          
          return state;
        };
        
        clearInterval(checkInterval);
        console.log('[Permission Checks Fix] Successfully patched Redux store');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Apply all patches
  function applyPatches() {
    // Create global permission checking function
    patchPermissionChecking();
    
    // Patch permission provider
    patchPermissionProvider();
    
    // Patch React components
    patchReactComponents();
    
    // Patch Redux store
    patchReduxStore();
    
    console.log('[Permission Checks Fix] All patches applied');
  }
  
  // Apply patches when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', applyPatches);
  } else {
    applyPatches();
  }
  
  console.log('[Permission Checks Fix] Initialization complete');
})();
</script>
<script>
// Direct Position API Fix
(function() {
  console.log('[Direct Position API Fix] Initializing...');
  
  // Store positions globally
  window.cachedPositions = null;
  
  // Define default permissions for different user types
  const DEFAULT_BASIC_PERMISSIONS = {
    dashboard: { view: true },
    "post-deal": { view: true, edit: true, create: true },
    book: { view: true, edit: true },
    settings: { view: true, edit: true }
  };
  
  const DEFAULT_ADMIN_PERMISSIONS = {
    dashboard: { view: true, edit: true, create: true, delete: true },
    "post-deal": { view: true, edit: true, create: true, delete: true },
    book: { view: true, edit: true, create: true, delete: true },
    agents: { view: true, edit: true, create: true, delete: true },
    configuration: { view: true, edit: true, create: true, delete: true },
    monitoring: { view: true, edit: true, create: true, delete: true },
    settings: { view: true, edit: true, create: true, delete: true },
    analytics: { view: true, edit: true, create: true, delete: true },
    users: { view: true, edit: true, create: true, delete: true }
  };
  
  // Helper function to get token from localStorage
  function getToken() {
    try {
      return localStorage.getItem('token') || '';
    } catch (error) {
      console.error('[Direct Position API Fix] Error getting token:', error);
      return '';
    }
  }
  
  // Function to fetch positions directly from API
  async function fetchPositionsDirectly() {
    try {
      console.log('[Direct Position API Fix] Fetching positions from API...');
      
      // Get token
      const token = getToken();
      
      // Prepare headers
      const headers = {
        'Content-Type': 'application/json'
      };
      
      // Add token if available
      if (token) {
        headers['Authorization'] = `Bearer ${token}`;
        console.log('[Direct Position API Fix] Added token to request');
      } else {
        console.log('[Direct Position API Fix] No token available for API request');
      }
      
      // Make API request
      const response = await fetch('/crm/api/positions', {
        method: 'GET',
        headers: headers
      });
      
      // Check if response is ok
      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}`);
      }
      
      // Parse response
      const positions = await response.json();
      
      console.log('[Direct Position API Fix] Fetched positions from API:', positions);
      
      // Store positions globally
      window.cachedPositions = positions;
      
      // Store positions in localStorage for fallback
      try {
        localStorage.setItem('cachedPositions', JSON.stringify(positions));
        console.log('[Direct Position API Fix] Stored positions in localStorage');
      } catch (error) {
        console.error('[Direct Position API Fix] Error storing positions in localStorage:', error);
      }
      
      return positions;
    } catch (error) {
      console.error('[Direct Position API Fix] Error fetching positions:', error);
      
      // Try to get positions from localStorage
      try {
        const cachedPositions = localStorage.getItem('cachedPositions');
        if (cachedPositions) {
          console.log('[Direct Position API Fix] Using cached positions from localStorage');
          const positions = JSON.parse(cachedPositions);
          window.cachedPositions = positions;
          return positions;
        }
      } catch (error) {
        console.error('[Direct Position API Fix] Error getting cached positions:', error);
      }
      
      return [];
    }
  }
  
  // Function to get position by ID
  function getPositionById(positionId) {
    // If positions are cached, use them
    if (window.cachedPositions && Array.isArray(window.cachedPositions)) {
      const position = window.cachedPositions.find(p => p.id === positionId);
      if (position) {
        return position;
      }
    }
    
    // If position not found, return default position
    return {
      id: positionId || 1,
      name: positionId === 6 ? 'Admin' : 'Agent',
      level: positionId === 6 ? 6 : 1,
      is_admin: positionId === 6,
      permissions: positionId === 6 ? DEFAULT_ADMIN_PERMISSIONS : DEFAULT_BASIC_PERMISSIONS
    };
  }
  
  // Function to get permissions for a user
  function getPermissionsForUser(user) {
    if (!user) return DEFAULT_BASIC_PERMISSIONS;
    
    // Normalize user object
    const normalizedUser = user.user ? user.user : user;
    
    // Check if user is admin
    const isAdmin = normalizedUser.role === 'admin' || 
                   normalizedUser.email === 'admin@americancoveragecenter.com' || 
                   (normalizedUser.position && normalizedUser.position.is_admin) || 
                   normalizedUser.position_id === 6;
    
    if (isAdmin) {
      return DEFAULT_ADMIN_PERMISSIONS;
    }
    
    // Get position ID
    const positionId = normalizedUser.position_id || 
                      (normalizedUser.position ? normalizedUser.position.id : null) || 
                      1;
    
    // Get position
    const position = getPositionById(positionId);
    
    // Return permissions from position or default
    return (position && position.permissions) ? position.permissions : DEFAULT_BASIC_PERMISSIONS;
  }
  
  // Function to check if user has permission
  function hasPermission(user, section, action) {
    console.log(`[Direct Position API Fix] Checking permission for ${section}/${action}`);
    
    // If no user, deny access
    if (!user) {
      console.log(`[Direct Position API Fix] No user, denying access to ${section}/${action}`);
      return false;
    }
    
    // Normalize user object
    const normalizedUser = user.user ? user.user : user;
    
    // Check if user is admin
    const isAdmin = normalizedUser.role === 'admin' || 
                   normalizedUser.email === 'admin@americancoveragecenter.com' || 
                   (normalizedUser.position && normalizedUser.position.is_admin) || 
                   normalizedUser.position_id === 6;
    
    if (isAdmin) {
      console.log(`[Direct Position API Fix] User is admin, granting access to ${section}/${action}`);
      return true;
    }
    
    // Get permissions
    const permissions = getPermissionsForUser(normalizedUser);
    
    // Check if section exists in permissions
    if (!permissions[section]) {
      console.log(`[Direct Position API Fix] No permission found for section: ${section}, checking defaults`);
      
      // Check default permissions
      const defaultPermissions = DEFAULT_BASIC_PERMISSIONS;
      if (defaultPermissions[section] && defaultPermissions[section][action]) {
        console.log(`[Direct Position API Fix] Default permission grants access to ${section}/${action}`);
        return true;
      }
      
      console.log(`[Direct Position API Fix] No permission found for ${section}/${action}, denying access`);
      return false;
    }
    
    // Check if action exists in section permissions
    if (!permissions[section][action]) {
      console.log(`[Direct Position API Fix] No permission found for action ${action} in section ${section}, denying access`);
      return false;
    }
    
    console.log(`[Direct Position API Fix] Access for ${section}/${action}: ${permissions[section][action]}`);
    return permissions[section][action];
  }
  
  // Function to patch permission checking
  function patchPermissionChecking() {
    console.log('[Direct Position API Fix] Patching permission checking...');
    
    // Override global hasPermission function
    window.hasPermission = function(user, section, action) {
      return hasPermission(user, section, action);
    };
    
    // Find and patch existing permission checking functions
    const potentialFunctions = [
      'hasPermission',
      'checkPermission',
      'canAccess',
      'hasAccess',
      'checkAccess'
    ];
    
    for (const funcName of potentialFunctions) {
      if (typeof window[funcName] === 'function' && funcName !== 'hasPermission') {
        const originalFunc = window[funcName];
        
        window[funcName] = function(user, section, action) {
          return hasPermission(user, section, action);
        };
        
        console.log(`[Direct Position API Fix] Patched ${funcName} function`);
      }
    }
  }
  
  // Function to patch React components
  function patchReactComponents() {
    console.log('[Direct Position API Fix] Patching React components...');
    
    // Wait for React to be loaded
    const checkInterval = setInterval(() => {
      if (window.React) {
        console.log('[Direct Position API Fix] React found, patching components...');
        
        // Original createElement function
        const originalCreateElement = window.React.createElement;
        
        // Override createElement to patch components
        window.React.createElement = function(type, props, ...children) {
          // If component has permission props
          if (props && (props.requiredPermission || props.requiredSection || props.requiredAction)) {
            const section = props.requiredSection || props.requiredPermission;
            const action = props.requiredAction || 'view';
            
            // Get current user from props or global state
            const user = props.user || (window.store && window.store.getState && window.store.getState().auth && window.store.getState().auth.user);
            
            // Check permission
            const hasPermission = window.hasPermission(user, section, action);
            
            // If no permission, return null or fallback
            if (!hasPermission && props.fallback) {
              return originalCreateElement.apply(this, [props.fallback, null, ...children]);
            } else if (!hasPermission) {
              return null;
            }
          }
          
          // Call original function
          return originalCreateElement.apply(this, [type, props, ...children]);
        };
        
        clearInterval(checkInterval);
        console.log('[Direct Position API Fix] Successfully patched React components');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Function to patch auth context
  function patchAuthContext() {
    console.log('[Direct Position API Fix] Patching auth context...');
    
    // Wait for auth context to be loaded
    const checkInterval = setInterval(() => {
      // Look for auth context or provider
      const authComponents = [
        'AuthContext',
        'AuthProvider',
        'PermissionContext',
        'PermissionProvider'
      ];
      
      let found = false;
      
      for (const componentName of authComponents) {
        if (window[componentName]) {
          console.log(`[Direct Position API Fix] Found ${componentName}, patching...`);
          
          // Store original component
          const originalComponent = window[componentName];
          
          // Override with patched version
          window[componentName] = function(...args) {
            const result = originalComponent.apply(this, args);
            
            // If result has a value property (React context)
            if (result && result.value) {
              // Add our permission checking function
              if (!result.value.hasPermission) {
                result.value.hasPermission = function(section, action) {
                  const user = result.value.user || result.value.currentUser;
                  return window.hasPermission(user, section, action);
                };
              }
              
              // Add getPositionById function
              if (!result.value.getPositionById) {
                result.value.getPositionById = getPositionById;
              }
              
              // Add getPermissionsForUser function
              if (!result.value.getPermissionsForUser) {
                result.value.getPermissionsForUser = getPermissionsForUser;
              }
            }
            
            return result;
          };
          
          found = true;
          console.log(`[Direct Position API Fix] Patched ${componentName}`);
        }
      }
      
      if (found) {
        clearInterval(checkInterval);
        console.log('[Direct Position API Fix] Successfully patched auth context');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Function to fetch positions on login
  function setupPositionFetching() {
    console.log('[Direct Position API Fix] Setting up position fetching...');
    
    // Fetch positions immediately
    fetchPositionsDirectly();
    
    // Fetch positions after login
    const originalFetch = window.fetch;
    window.fetch = async function(url, options) {
      const result = await originalFetch.apply(this, arguments);
      
      // Clone result to avoid consuming it
      const clonedResult = result.clone();
      
      // Check if this is a login request
      if (typeof url === 'string' && url.includes('/auth/login') && options && options.method === 'POST') {
        try {
          const data = await clonedResult.json();
          
          // If login successful, fetch positions
          if (data && data.token) {
            console.log('[Direct Position API Fix] Login successful, fetching positions...');
            setTimeout(fetchPositionsDirectly, 500);
          }
        } catch (error) {
          // Ignore errors
        }
      }
      
      return result;
    };
    
    // Listen for storage events to detect token changes
    window.addEventListener('storage', function(event) {
      if (event.key === 'token' && event.newValue) {
        console.log('[Direct Position API Fix] Token changed, fetching positions...');
        fetchPositionsDirectly();
      }
    });
    
    // Fetch positions periodically
    setInterval(fetchPositionsDirectly, 60000);
  }
  
  // Apply all patches
  function applyPatches() {
    // Patch permission checking
    patchPermissionChecking();
    
    // Patch React components
    patchReactComponents();
    
    // Patch auth context
    patchAuthContext();
    
    // Setup position fetching
    setupPositionFetching();
    
    console.log('[Direct Position API Fix] All patches applied');
  }
  
  // Apply patches when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', applyPatches);
  } else {
    applyPatches();
  }
  
  console.log('[Direct Position API Fix] Initialization complete');
})();
</script>
<script>
// Position Token Handling Fix
(function() {
  console.log('[Position Token Handling Fix] Initializing...');
  
  // Function to get token from localStorage
  function getToken() {
    try {
      return localStorage.getItem('token') || '';
    } catch (error) {
      console.error('[Position Token Handling Fix] Error getting token:', error);
      return '';
    }
  }
  
  // Function to fetch positions with token
  async function fetchPositionsWithToken() {
    try {
      console.log('[Position Token Handling Fix] Fetching positions with token...');
      
      // Get token
      const token = getToken();
      if (!token) {
        console.log('[Position Token Handling Fix] No token available, skipping position fetch');
        return null;
      }
      
      // Prepare headers with token
      const headers = {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      };
      
      // Make API request to positions endpoint
      const response = await fetch('/crm/api/positions', {
        method: 'GET',
        headers: headers
      });
      
      // Check if response is ok
      if (!response.ok) {
        throw new Error(`API request failed with status ${response.status}`);
      }
      
      // Parse response
      const positions = await response.json();
      console.log('[Position Token Handling Fix] Successfully fetched positions:', positions);
      
      // Store positions in global variable and localStorage
      window.positionsData = positions;
      try {
        localStorage.setItem('positionsData', JSON.stringify(positions));
      } catch (error) {
        console.error('[Position Token Handling Fix] Error storing positions in localStorage:', error);
      }
      
      return positions;
    } catch (error) {
      console.error('[Position Token Handling Fix] Error fetching positions:', error);
      return null;
    }
  }
  
  // Function to get position by ID
  function getPositionById(positionId) {
    // Try to get from global variable
    if (window.positionsData && Array.isArray(window.positionsData)) {
      const position = window.positionsData.find(p => p.id === positionId);
      if (position) {
        return position;
      }
    }
    
    // Try to get from localStorage
    try {
      const positionsData = localStorage.getItem('positionsData');
      if (positionsData) {
        const positions = JSON.parse(positionsData);
        const position = positions.find(p => p.id === positionId);
        if (position) {
          return position;
        }
      }
    } catch (error) {
      console.error('[Position Token Handling Fix] Error getting position from localStorage:', error);
    }
    
    // Return default position if not found
    return {
      id: positionId || 1,
      name: positionId === 6 ? 'Admin' : 'Agent',
      level: positionId === 6 ? 6 : 1,
      is_admin: positionId === 6,
      permissions: positionId === 6 ? {
        dashboard: { view: true, edit: true, create: true, delete: true },
        "post-deal": { view: true, edit: true, create: true, delete: true },
        book: { view: true, edit: true, create: true, delete: true },
        agents: { view: true, edit: true, create: true, delete: true },
        configuration: { view: true, edit: true, create: true, delete: true },
        monitoring: { view: true, edit: true, create: true, delete: true },
        settings: { view: true, edit: true, create: true, delete: true },
        analytics: { view: true, edit: true, create: true, delete: true },
        users: { view: true, edit: true, create: true, delete: true }
      } : {
        dashboard: { view: true },
        "post-deal": { view: true, edit: true, create: true },
        book: { view: true, edit: true },
        settings: { view: true, edit: true }
      }
    };
  }
  
  // Function to patch position fetching
  function patchPositionFetching() {
    console.log('[Position Token Handling Fix] Patching position fetching...');
    
    // Override global getPositionById function if it exists
    if (typeof window.getPositionById === 'function') {
      const originalGetPositionById = window.getPositionById;
      window.getPositionById = function(positionId) {
        const position = getPositionById(positionId);
        if (position) {
          return position;
        }
        return originalGetPositionById(positionId);
      };
      console.log('[Position Token Handling Fix] Patched global getPositionById function');
    } else {
      // Add global getPositionById function if it doesn't exist
      window.getPositionById = getPositionById;
      console.log('[Position Token Handling Fix] Added global getPositionById function');
    }
    
    // Add global fetchPositionsWithToken function
    window.fetchPositionsWithToken = fetchPositionsWithToken;
    console.log('[Position Token Handling Fix] Added global fetchPositionsWithToken function');
  }
  
  // Function to patch API calls
  function patchApiCalls() {
    console.log('[Position Token Handling Fix] Patching API calls...');
    
    // Override fetch to add token to position API calls
    const originalFetch = window.fetch;
    window.fetch = async function(url, options = {}) {
      // If this is a positions API call
      if (typeof url === 'string' && url.includes('/api/positions')) {
        console.log('[Position Token Handling Fix] Intercepted positions API call');
        
        // Get token
        const token = getToken();
        
        // Add token to headers if available
        if (token) {
          options.headers = options.headers || {};
          options.headers['Authorization'] = `Bearer ${token}`;
          console.log('[Position Token Handling Fix] Added token to positions API call');
        }
      }
      
      // Call original fetch
      return originalFetch.apply(this, arguments);
    };
    
    console.log('[Position Token Handling Fix] Patched fetch for position API calls');
  }
  
  // Function to patch user object
  function patchUserObject() {
    console.log('[Position Token Handling Fix] Patching user object...');
    
    // Override Object.defineProperty to intercept user object
    const originalDefineProperty = Object.defineProperty;
    Object.defineProperty = function(obj, prop, descriptor) {
      // If this is setting a user property
      if (prop === 'user' && descriptor && descriptor.value) {
        console.log('[Position Token Handling Fix] Intercepted user object assignment');
        
        // Get user object
        const user = descriptor.value;
        
        // If user has position_id but no position
        if (user && user.position_id && !user.position) {
          console.log('[Position Token Handling Fix] User has position_id but no position, fetching position');
          
          // Get position
          const position = getPositionById(user.position_id);
          
          // Add position to user
          if (position) {
            user.position = position;
            console.log('[Position Token Handling Fix] Added position to user object');
          }
        }
      }
      
      // Call original defineProperty
      return originalDefineProperty.apply(this, arguments);
    };
    
    console.log('[Position Token Handling Fix] Patched Object.defineProperty for user object');
  }
  
  // Function to setup event listeners
  function setupEventListeners() {
    console.log('[Position Token Handling Fix] Setting up event listeners...');
    
    // Listen for token changes
    window.addEventListener('storage', function(event) {
      if (event.key === 'token' && event.newValue) {
        console.log('[Position Token Handling Fix] Token changed, fetching positions...');
        fetchPositionsWithToken();
      }
    });
    
    // Listen for login events
    document.addEventListener('login', function() {
      console.log('[Position Token Handling Fix] Login event detected, fetching positions...');
      fetchPositionsWithToken();
    });
    
    // Fetch positions on page load
    window.addEventListener('load', function() {
      console.log('[Position Token Handling Fix] Page loaded, fetching positions...');
      setTimeout(fetchPositionsWithToken, 1000);
    });
    
    // Intercept login API calls
    const originalFetch = window.fetch;
    window.fetch = async function(url, options) {
      const result = await originalFetch.apply(this, arguments);
      
      // Clone result to avoid consuming it
      const clonedResult = result.clone();
      
      // Check if this is a login request
      if (typeof url === 'string' && url.includes('/auth/login') && options && options.method === 'POST') {
        try {
          const data = await clonedResult.json();
          
          // If login successful, fetch positions
          if (data && data.token) {
            console.log('[Position Token Handling Fix] Login successful, fetching positions...');
            setTimeout(fetchPositionsWithToken, 1000);
            
            // Dispatch login event
            document.dispatchEvent(new Event('login'));
          }
        } catch (error) {
          // Ignore errors
        }
      }
      
      return result;
    };
    
    console.log('[Position Token Handling Fix] Event listeners set up');
  }
  
  // Apply all patches
  function applyPatches() {
    // Patch position fetching
    patchPositionFetching();
    
    // Patch API calls
    patchApiCalls();
    
    // Patch user object
    patchUserObject();
    
    // Setup event listeners
    setupEventListeners();
    
    // Fetch positions immediately
    fetchPositionsWithToken();
    
    console.log('[Position Token Handling Fix] All patches applied');
  }
  
  // Apply patches when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', applyPatches);
  } else {
    applyPatches();
  }
  
  console.log('[Position Token Handling Fix] Initialization complete');
})();
</script>
<script>
// Hardcoded Permissions Fix
(function() {
  console.log('[Hardcoded Permissions Fix] Initializing...');
  
  // Define critical sections that all users must have access to
  const CRITICAL_SECTIONS = {
    dashboard: { view: true },
    "post-deal": { view: true, edit: true, create: true },
    book: { view: true, edit: true },
    settings: { view: true, edit: true }
  };
  
  // Define admin sections with full permissions
  const ADMIN_SECTIONS = {
    dashboard: { view: true, edit: true, create: true, delete: true },
    "post-deal": { view: true, edit: true, create: true, delete: true },
    book: { view: true, edit: true, create: true, delete: true },
    agents: { view: true, edit: true, create: true, delete: true },
    configuration: { view: true, edit: true, create: true, delete: true },
    monitoring: { view: true, edit: true, create: true, delete: true },
    settings: { view: true, edit: true, create: true, delete: true },
    analytics: { view: true, edit: true, create: true, delete: true },
    users: { view: true, edit: true, create: true, delete: true }
  };
  
  // Function to check if user is admin
  function isAdmin(user) {
    if (!user) return false;
    
    // Normalize user object
    const normalizedUser = user.user ? user.user : user;
    
    return normalizedUser.role === 'admin' || 
           normalizedUser.email === 'admin@americancoveragecenter.com' || 
           (normalizedUser.position && normalizedUser.position.is_admin) || 
           normalizedUser.position_id === 6;
  }
  
  // Override hasPermission function
  function hardcodedHasPermission(user, section, action) {
    console.log(`[Hardcoded Permissions Fix] Checking permission for ${section}/${action}`);
    
    // If no user, deny access
    if (!user) {
      console.log(`[Hardcoded Permissions Fix] No user, denying access to ${section}/${action}`);
      return false;
    }
    
    // Check if user is admin
    if (isAdmin(user)) {
      console.log(`[Hardcoded Permissions Fix] User is admin, granting access to ${section}/${action}`);
      return true;
    }
    
    // For critical sections, always grant access if the action is supported
    if (CRITICAL_SECTIONS[section] && CRITICAL_SECTIONS[section][action]) {
      console.log(`[Hardcoded Permissions Fix] Critical section ${section}/${action}, granting access`);
      return true;
    }
    
    // For non-critical sections, try to use the original permission system
    try {
      // If there's an existing permission system, use it for non-critical sections
      if (window._originalHasPermission) {
        return window._originalHasPermission(user, section, action);
      }
    } catch (error) {
      console.error(`[Hardcoded Permissions Fix] Error checking original permissions: ${error.message}`);
    }
    
    // Default deny for non-critical sections
    console.log(`[Hardcoded Permissions Fix] Non-critical section ${section}/${action}, denying access`);
    return false;
  }
  
  // Function to patch permission checking
  function patchPermissionChecking() {
    console.log('[Hardcoded Permissions Fix] Patching permission checking...');
    
    // Store original hasPermission function if it exists
    if (typeof window.hasPermission === 'function') {
      window._originalHasPermission = window.hasPermission;
    }
    
    // Override global hasPermission function
    window.hasPermission = hardcodedHasPermission;
    
    // Find and patch existing permission checking functions
    const potentialFunctions = [
      'checkPermission',
      'canAccess',
      'hasAccess',
      'checkAccess'
    ];
    
    for (const funcName of potentialFunctions) {
      if (typeof window[funcName] === 'function') {
        const originalFunc = window[funcName];
        window['_original' + funcName] = originalFunc;
        
        window[funcName] = function(user, section, action) {
          return hardcodedHasPermission(user, section, action);
        };
        
        console.log(`[Hardcoded Permissions Fix] Patched ${funcName} function`);
      }
    }
  }
  
  // Function to patch React components
  function patchReactComponents() {
    console.log('[Hardcoded Permissions Fix] Patching React components...');
    
    // Wait for React to be loaded
    const checkInterval = setInterval(() => {
      if (window.React) {
        console.log('[Hardcoded Permissions Fix] React found, patching components...');
        
        // Original createElement function
        const originalCreateElement = window.React.createElement;
        
        // Override createElement to patch components
        window.React.createElement = function(type, props, ...children) {
          // If component has permission props
          if (props && (props.requiredPermission || props.requiredSection || props.requiredAction)) {
            const section = props.requiredSection || props.requiredPermission;
            const action = props.requiredAction || 'view';
            
            // Get current user from props or global state
            const user = props.user || (window.store && window.store.getState && window.store.getState().auth && window.store.getState().auth.user);
            
            // For critical sections, always render the component
            if (CRITICAL_SECTIONS[section] && CRITICAL_SECTIONS[section][action]) {
              // Continue with original createElement
              return originalCreateElement.apply(this, [type, props, ...children]);
            }
            
            // For admin users, always render the component
            if (user && isAdmin(user)) {
              return originalCreateElement.apply(this, [type, props, ...children]);
            }
            
            // For other sections, check permission
            const hasPermission = window.hasPermission(user, section, action);
            
            // If no permission, return null or fallback
            if (!hasPermission && props.fallback) {
              return originalCreateElement.apply(this, [props.fallback, null, ...children]);
            } else if (!hasPermission) {
              return null;
            }
          }
          
          // Call original function
          return originalCreateElement.apply(this, [type, props, ...children]);
        };
        
        clearInterval(checkInterval);
        console.log('[Hardcoded Permissions Fix] Successfully patched React components');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Function to patch auth context
  function patchAuthContext() {
    console.log('[Hardcoded Permissions Fix] Patching auth context...');
    
    // Wait for auth context to be loaded
    const checkInterval = setInterval(() => {
      // Look for auth context or provider
      const authComponents = [
        'AuthContext',
        'AuthProvider',
        'PermissionContext',
        'PermissionProvider'
      ];
      
      let found = false;
      
      for (const componentName of authComponents) {
        if (window[componentName]) {
          console.log(`[Hardcoded Permissions Fix] Found ${componentName}, patching...`);
          
          // Store original component
          const originalComponent = window[componentName];
          
          // Override with patched version
          window[componentName] = function(...args) {
            const result = originalComponent.apply(this, args);
            
            // If result has a value property (React context)
            if (result && result.value) {
              // Add our permission checking function
              if (!result.value.hasPermission) {
                result.value.hasPermission = function(section, action) {
                  const user = result.value.user || result.value.currentUser;
                  return hardcodedHasPermission(user, section, action);
                };
              } else {
                // Override existing hasPermission
                const originalContextHasPermission = result.value.hasPermission;
                result.value._originalHasPermission = originalContextHasPermission;
                
                result.value.hasPermission = function(section, action) {
                  const user = result.value.user || result.value.currentUser;
                  return hardcodedHasPermission(user, section, action);
                };
              }
            }
            
            return result;
          };
          
          found = true;
          console.log(`[Hardcoded Permissions Fix] Patched ${componentName}`);
        }
      }
      
      if (found) {
        clearInterval(checkInterval);
        console.log('[Hardcoded Permissions Fix] Successfully patched auth context');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Function to patch route guards
  function patchRouteGuards() {
    console.log('[Hardcoded Permissions Fix] Patching route guards...');
    
    // Wait for router to be loaded
    const checkInterval = setInterval(() => {
      // Look for router components
      const routerComponents = [
        'Router',
        'BrowserRouter',
        'Route',
        'PrivateRoute',
        'ProtectedRoute'
      ];
      
      let found = false;
      
      for (const componentName of routerComponents) {
        if (window[componentName]) {
          console.log(`[Hardcoded Permissions Fix] Found ${componentName}, patching...`);
          
          // If it's a route guard component
          if (componentName === 'PrivateRoute' || componentName === 'ProtectedRoute') {
            const originalComponent = window[componentName];
            
            window[componentName] = function(...args) {
              // Get props from args
              const props = args[0] || {};
              
              // If it has permission requirements
              if (props.requiredPermission || props.requiredSection || props.requiredAction) {
                const section = props.requiredSection || props.requiredPermission;
                const action = props.requiredAction || 'view';
                
                // For critical sections, always allow access
                if (CRITICAL_SECTIONS[section] && CRITICAL_SECTIONS[section][action]) {
                  // Remove permission requirements
                  const newProps = { ...props };
                  delete newProps.requiredPermission;
                  delete newProps.requiredSection;
                  delete newProps.requiredAction;
                  
                  args[0] = newProps;
                }
              }
              
              return originalComponent.apply(this, args);
            };
            
            found = true;
            console.log(`[Hardcoded Permissions Fix] Patched ${componentName}`);
          }
        }
      }
      
      if (found) {
        clearInterval(checkInterval);
        console.log('[Hardcoded Permissions Fix] Successfully patched route guards');
      }
    }, 500);
    
    // Clear interval after 10 seconds to prevent memory leaks
    setTimeout(() => {
      clearInterval(checkInterval);
    }, 10000);
  }
  
  // Apply all patches
  function applyPatches() {
    // Patch permission checking
    patchPermissionChecking();
    
    // Patch React components
    patchReactComponents();
    
    // Patch auth context
    patchAuthContext();
    
    // Patch route guards
    patchRouteGuards();
    
    console.log('[Hardcoded Permissions Fix] All patches applied');
  }
  
  // Apply patches when DOM is loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', applyPatches);
  } else {
    applyPatches();
  }
  
  // Also apply patches after login
  const originalFetch = window.fetch;
  window.fetch = async function(url, options) {
    const result = await originalFetch.apply(this, arguments);
    
    // Clone result to avoid consuming it
    const clonedResult = result.clone();
    
    // Check if this is a login request
    if (typeof url === 'string' && url.includes('/auth/login') && options && options.method === 'POST') {
      try {
        const data = await clonedResult.json();
        
        // If login successful, apply patches
        if (data && data.token) {
          console.log('[Hardcoded Permissions Fix] Login successful, applying patches...');
          setTimeout(applyPatches, 500);
        }
      } catch (error) {
        // Ignore errors
      }
    }
    
    return result;
  };
  
  // Apply patches on page refresh
  window.addEventListener('load', function() {
    console.log('[Hardcoded Permissions Fix] Page loaded, applying patches...');
    setTimeout(applyPatches, 500);
  });
  
  console.log('[Hardcoded Permissions Fix] Initialization complete');
})();
</script>
</body>
</html>